import Control.Monad

bind :: Monad m => (a -> m b) -> m a -> m b
bind f x = join $ fmap f x
-- bind, or the >>= operator is an fmap, then a join
-- f is a function that works on a monad, and x is encapsulated inside a monad

twiceWhenEven :: [Integer] -> [Integer]
twiceWhenEven xs = do
  x <- xs
  if even x
    then [x*x, x*x]
    else [x*x]

twiceWhenEven' :: [Integer] -> [Integer]
twiceWhenEven' xs = do
  x <- xs
  if even x
    then [x*x, x*x]
    else []
-- these apply to all values in the input list
-- looks like monads can be used almost like a for loop in this way
-- though more like a list comprehension in haskell

-- Cow example
data Cow = Cow {
      name   :: String
    , age    :: Int
    , weight :: Int
} deriving (Eq, Show)

noEmpty :: String -> Maybe String
noEmpty "" = Nothing
noEmpty str = Just str

noNegative :: Int -> Maybe Int
noNegative n | n >= 0 = Just n
             | otherwise = Nothing

-- if Cow's name is Bess, must be under 500
weightCheck :: Cow -> Maybe Cow
weightCheck c =
  let w = weight c
      n = name c   -- Pattern matching from within the Cow structure
  in if n == "Bess" && w > 499
    then Nothing
    else Just c

mkSphericalCow :: String -> Int -> Int -> Maybe Cow
mkSphericalCow name' age' weight' =
  case noEmpty name' of
    Nothing -> Nothing
    Just nammy ->  -- First check if noEmpty returns a Just value, then go one level deeper in our check
      case noNegative age' of
        Nothing -> Nothing
        Just agey ->
          case noNegative weight' of
            Nothing -> Nothing
            Just weighty ->
              weightCheck (Cow nammy agey weighty) -- finally, invoke weightCheck for the Bess conditon, if all else is ok
-- This is confusing and verbose, so we want to clean it up with Monad


mkSphericalCow' :: String -> Int -> Int -> Maybe Cow
mkSphericalCow' name' age' weight' = do
  nammy <- noEmpty name'
  agey <- noNegative age'
  weighty <- noNegative weight'
  weightCheck (Cow nammy agey weighty)
  -- ahh, much nicer

-- can also write this with the bind or 'shove' operator, if we like
mkSphericalCow'' :: String -> Int -> Int -> Maybe Cow
mkSphericalCow'' name' age' weight' =
  noEmpty name' >>=
    \ nammy ->
      noNegative age' >>=
      \ agey ->
        noNegative weight' >>=
        \ weighty ->
        weightCheck (Cow nammy agey weighty)
        -- however, we CANNOT do this with just an applicative.
        -- Because the weightCheck function depends on the prior existence of a Cow value
        -- and reutns more monadic structure in its return type Maybe Cow

-- We can use applicative for this:
  doSomething = do
    a <- f
    b <- g
    c <- h
    pure (a, b, c)

-- but we MUST use monad for something like this
  doSoemthing' n = do
    a <- f n
    b <- g a
    c <- h b
    pure (a, b, c)
    -- this depends on values generated by monadic structres in g and h,
    -- so we need the 'join', in monad, to remove the nesting
    -- monads are a sequencing structure, depending on what happened previously
    -- previous computations and wither they have failed, in Maybe, affect the final result
    -- but in applicative, like the doSomething without the prime ('), each Maybe computation is independent
    -- in doSomething', we pass the previous result along, just like in the weightCheck function for Cow
    -- there's a key difference between Monad and Applicative, for this reason
    -- When we sequence Monads with Maybe and >>=, we can return a Nothing for the WHOLE COMPUTATION,
    -- as soon as any SINGLE function in our sequence returns a Nothing. We don't do that with applicative.
    -- As in the Cow example, the alternative to using Monad is checkinf for Nothing -> Nothing each step of the
    -- computation and doing a ton of repetition. That sucks and is too tedious. Monad can help us avoid this needless repetition.




